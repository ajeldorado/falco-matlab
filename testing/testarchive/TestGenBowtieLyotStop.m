%---------------------------------------------------------------------------
% Copyright 2018-2021, by the California Institute of Technology. ALL RIGHTS
% RESERVED. United States Government Sponsorship acknowledged. Any
% commercial use must be negotiated with the Office of Technology Transfer
% at the California Institute of Technology.
%---------------------------------------------------------------------------
%% Test falco_gen_bowtie_LS.m
%
% We define some tests for falco_gen_bowtie_LS.m to test responses to
% different input parameters. 
classdef TestGenBowtieLyotStop < matlab.unittest.TestCase    
%% Properties
%
% A presaved file with FALCO parameters was saved and is lodaded to be used
% by methods. In this case we only use the mp.path.falco + lib/utils to
% addpath to utils functions to be tested.
%     properties
%         mp=Parameters();
%     end

%% Setup and Teardown Methods
%
%  Add and remove path to library functions to be tested.

    methods (TestClassSetup)
        function addPath(testCase)
            pathToFalco = fileparts(fileparts(fileparts(mfilename('fullpath')))); % falco-matlab directory;
            addpath(genpath([pathToFalco filesep 'lib']));
            addpath(genpath([pathToFalco filesep 'lib_external']));
        end
    end
    methods (TestClassTeardown)
        function removePath(testCase)
            pathToFalco = fileparts(fileparts(fileparts(mfilename('fullpath')))); % falco-matlab directory;
            rmpath(genpath([pathToFalco filesep 'lib']));
            addpath(genpath([pathToFalco filesep 'lib_external']));
        end
    end
     
%% Tests
%
%  Creates four tests:
%
% # *testBowtieArea* Verity that the area of the bowtie generated by
%                     falco_gen_bowtie_FPM.m is within 0.1% of the
%                     expected area.
% # *testBowtieTranslation* Verity that the the actual translation of
%                            the bowtie is equal to the expected translation.
% # *testBowtieshape* Verify that the shape of the bowtie with rund corners
%                     satisfies the constraint sum(abs(diffFillet(:)))/inputs.pixresFPM^2 < pi*inputs.Rfillet^2
% # *testBowtieTranslationRotation* Verify that the translated and rotated 
%                                   bowtie satisties the constraint
%                                   diff<1e-4 where diff = pad_crop(fpmRot, size(fpmOffset))...
%                                   - circshift(fpmRotOffset, -inputs.pixresFPM*[inputs.yOffset, inputs.xOffset]);   
    methods (Test)    
        function testBowtieLSArea(testCase)
            inputs.Nbeam = 100; % number of points across the incoming beam
            inputs.ID = 0.38; % inner diameter of mask (in pupil diameters)
            inputs.OD = 0.91; % outer diameter of mask (in pupil diameters)
            inputs.ang = 90; %opening angle of the upper and lower bowtie wedges (degrees)
            inputs.clocking = 10;
            lyot = falco_gen_bowtie_LS(inputs);
            
            areaExpected = pi/4*(inputs.OD^2 - inputs.ID^2)*(2*inputs.ang/360)*(inputs.Nbeam^2);
            area = sum(lyot(:));

            import matlab.unittest.constraints.IsEqualTo
            import matlab.unittest.constraints.RelativeTolerance
            testCase.verifyThat(area, IsEqualTo(areaExpected,'Within', RelativeTolerance(0.001)))
        end
        function testBowtieLSTranslation(testCase)
            inputs.Nbeam = 100; % number of points across the incoming beam
            inputs.ID = 0.38; % inner diameter of mask (in pupil diameters)
            inputs.OD = 0.91; % outer diameter of mask (in pupil diameters)
            inputs.ang = 90; %opening angle of the upper and lower bowtie wedges (degrees)
            inputs.clocking = 10;
            lyot = falco_gen_bowtie_LS(inputs);
            
            inputs.xShear = -11/100;
            inputs.yShear = 19/100;
            lyotOffset = falco_gen_bowtie_LS(inputs);
            diff = pad_crop(lyot, size(lyotOffset)) - circshift(lyotOffset, -inputs.Nbeam*[inputs.yShear, inputs.xShear]);
            testCase.verifyLessThan(sum(abs(diff(:))), 1e-8)             
        end
        function testBowtieLSTranslationRotation(testCase)
            inputs.Nbeam = 100; % number of points across the incoming beam           
            inputs.ID = 0.38; % inner diameter of mask (in pupil diameters)
            inputs.OD = 0.91; % outer diameter of mask (in pupil diameters)
            inputs.ang = 90; %opening angle of the upper and lower bowtie wedges (degrees)
            inputs.clocking = 10;
            lyot = falco_gen_bowtie_LS(inputs);
            
            inputs.xShear = -11/100;
            inputs.yShear = 19/100;
            lyotOffset = falco_gen_bowtie_LS(inputs);
            
            inputs.clocking = 90+inputs.clocking;
            lyotRotOffset = falco_gen_bowtie_LS(inputs);

            lyotRot = zeros(size(lyot));
            lyotRot(2:end, 2:end) = rot90(lyot(2:end, 2:end), -1);
            diff = pad_crop(lyotRot, size(lyotOffset)) - circshift(lyotRotOffset, -inputs.Nbeam*[inputs.yShear, inputs.xShear]);
                 
            testCase.verifyLessThan(sum(abs(diff(:))/sum(lyotRotOffset(:))), 1e-4) 
        end
        function testBowtieTranslationRotation(testCase)
            Nbeam = 300;
            ID = 0.41;
            OD = 0.87;
            angDeg = 89;
            
            DbeamUM = 10e3;
            xc = 5e3;
            yc = -2e3;
            
            inputs.Nbeam = Nbeam;     % number of points across the incoming beam
            inputs.ID = ID; % inner diameter of mask (in pupil diameters)
            inputs.OD = OD; % outer diameter of mask (in pupil diameters)
            inputs.ang = angDeg; %opening angle of the upper and lower bowtie wedges (degrees)
            inputs.xShear = xc/DbeamUM;
            inputs.yShear = yc/DbeamUM;
            inputs.clocking = 25;
            
            maskSharp = falco_gen_bowtie_LS(inputs);
            
            inputs.Rfillet = 0.03;
            maskRounded = falco_gen_bowtie_LS(inputs);
            diffFillet = maskSharp - maskRounded;
            testCase.verifyLessThan(sum(abs(diffFillet(:)))/inputs.Nbeam^2, pi*inputs.Rfillet^2) 
        end
    end    
end