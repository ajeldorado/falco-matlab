%% Test Orientation of DM Surfaces Generated by Model
%
% Unit tests of DM orientation in falco_gen_dm_surf() and
% falco_gen_dm_poke_cube().
%
classdef TestDMOrientation < matlab.unittest.TestCase
    %% Setup and Teardown Methods
    %
    %  Add and remove path to utils functions to be tested.
    %
    methods (TestClassSetup)
        function addPath(testCase)
            addpath(genpath('../../lib'));
            addpath(genpath('../../lib_external'));
        end
    end
    methods (TestClassTeardown)
        function removePath(testCase)
            rmpath(genpath('../../lib'));
            rmpath(genpath('../../lib_external'));
        end
    end
    
    %% Unit tests

    methods (Test)

        function testDMSurfOrientation(testCase)
            
            Nact = 48;
            fCommand = zeros(Nact, Nact);
            fCommand(30:40, 32) = 1;
            fCommand(40, 32:38) = 1;
            fCommand(35, 32:36) = 1;
            mp.dm1.V = fCommand;
            
            %--DM1 parameters
            mp.dm1.centering = 'pixel';
            mp.dm1.Nact = Nact;               % # of actuators across DM array
            mp.dm1.VtoH = 0.9*ones(mp.dm1.Nact);  % gains of all actuators [nm/V of free stroke]
            mp.dm1.xtilt = 0;               % for foreshortening. angle of rotation about x-axis [degrees]
            mp.dm1.ytilt = 0;               % for foreshortening. angle of rotation about y-axis [degrees]
            mp.dm1.zrot = 0;                % clocking of DM surface [degrees]
            mp.dm1.xc = (mp.dm1.Nact/2 - 1/2);       % x-center location of DM surface [actuator widths]
            mp.dm1.yc = (mp.dm1.Nact/2 - 1/2);       % y-center location of DM surface [actuator widths]
            
            mp.dm1.fitType = 'linear';
            mp.dm1.dead = [];
            mp.dm1.pinned = [];
            mp.dm1.Vpinned = zeros(size(mp.dm1.pinned));
            mp.dm1.tied = zeros(0,2);
            mp.dm1.Vmin = 0;
            mp.dm1.Vmax = 100;
            mp.dm1.dVnbrLat = mp.dm1.Vmax;
            mp.dm1.dVnbrDiag = mp.dm1.Vmax; 
            mp.dm1.biasMap = mp.dm1.Vmax/2*ones(mp.dm1.Nact, mp.dm1.Nact);
            mp.dm1.facesheetFlatmap = mp.dm1.biasMap;
            
            mp.dm1.inf_fn = 'influence_BMC_2kDM_400micron_res10.fits';
            mp.dm1.dm_spacing = 400e-6; %--User defined actuator pitch [meters]
            mp.dm1.inf_sign = '+';
            
            
            ppact = 3;
            dx = mp.dm1.dm_spacing/ppact;
            Narray = ceil(ppact*Nact*1.5/2)*2 + 1; % Needs to be odd-valued for these tests
            
            %--Change to mp.dm1.V orientation before generating DM surface. Options: rot0, rot90, rot180, rot270, flipxrot0, flipxrot90, flipxrot180, flipxrot270
            mp.dm1.orientation = 'rot0'; 
            surfRot0 = falco_gen_dm_surf(mp.dm1, dx, Narray);

            mp.dm1.orientation = 'rot90';
            surfRot90 = falco_gen_dm_surf(mp.dm1, dx, Narray);
            
            mp.dm1.orientation = 'rot180';
            surfRot180 = falco_gen_dm_surf(mp.dm1, dx, Narray);
            
            mp.dm1.orientation = 'rot270';
            surfRot270 = falco_gen_dm_surf(mp.dm1, dx, Narray);
            
            mp.dm1.orientation = 'flipxrot0'; 
            surfFlipxRot0 = falco_gen_dm_surf(mp.dm1, dx, Narray);

            mp.dm1.orientation = 'flipxrot90';
            surfFlipxRot90 = falco_gen_dm_surf(mp.dm1, dx, Narray);
            
            mp.dm1.orientation = 'flipxrot180';
            surfFlipxRot180 = falco_gen_dm_surf(mp.dm1, dx, Narray);
            
            mp.dm1.orientation = 'flipxrot270';
            surfFlipxRot270 = falco_gen_dm_surf(mp.dm1, dx, Narray);


            abs_tol = 100*eps;
            
            maxAbsDiff = max(max(abs(surfRot0 - rot90(surfRot90, -1))));
            testCase.verifyTrue(maxAbsDiff < abs_tol)
            
            maxAbsDiff = max(max(abs(surfRot0 - rot90(surfRot180, -2))));
            testCase.verifyTrue(maxAbsDiff < abs_tol)
           
            maxAbsDiff = max(max(abs(surfRot0 - rot90(surfRot270, -3))));
            testCase.verifyTrue(maxAbsDiff < abs_tol)
            
            maxAbsDiff = max(max(abs(surfRot0 - fliplr(surfFlipxRot0))));
            testCase.verifyTrue(maxAbsDiff < abs_tol)
            
            maxAbsDiff = max(max(abs(surfRot0 - fliplr(rot90(surfFlipxRot90, -1)))));
            testCase.verifyTrue(maxAbsDiff < abs_tol)
            
            maxAbsDiff = max(max(abs(surfRot0 - fliplr(rot90(surfFlipxRot180, -2)))));
            testCase.verifyTrue(maxAbsDiff < abs_tol)
           
            maxAbsDiff = max(max(abs(surfRot0 - fliplr(rot90(surfFlipxRot270, -3)))));
            testCase.verifyTrue(maxAbsDiff < abs_tol)
            
        end
        
        
        function testDMSurfOrientationFromCube(testCase)
            
            Nact = 48;
            fCommand = zeros(Nact, Nact);
            fCommand(30:40, 32) = 1;
            fCommand(40, 32:38) = 1;
            fCommand(35, 32:36) = 1;
            mp.dm1.V = fCommand;
            
            %--DM1 parameters
            mp.dm1.centering = 'pixel';
            mp.dm1.Nact = Nact;               % # of actuators across DM array
            mp.dm1.VtoH = 0.9*ones(mp.dm1.Nact);  % gains of all actuators [nm/V of free stroke]
            mp.dm1.xtilt = 0;               % for foreshortening. angle of rotation about x-axis [degrees]
            mp.dm1.ytilt = 0;               % for foreshortening. angle of rotation about y-axis [degrees]
            mp.dm1.zrot = 0;                % clocking of DM surface [degrees]
            mp.dm1.xc = (mp.dm1.Nact/2 - 1/2);       % x-center location of DM surface [actuator widths]
            mp.dm1.yc = (mp.dm1.Nact/2 - 1/2);       % y-center location of DM surface [actuator widths]
            
            mp.dm1.fitType = 'linear';
            mp.dm1.dead = [];
            mp.dm1.pinned = [];
            mp.dm1.Vpinned = zeros(size(mp.dm1.pinned));
            mp.dm1.tied = zeros(0,2);
            mp.dm1.Vmin = 0;
            mp.dm1.Vmax = 100;
            mp.dm1.dVnbrLat = mp.dm1.Vmax;
            mp.dm1.dVnbrDiag = mp.dm1.Vmax; 
            mp.dm1.biasMap = mp.dm1.Vmax/2*ones(mp.dm1.Nact, mp.dm1.Nact);
            mp.dm1.facesheetFlatmap = mp.dm1.biasMap;
            
            mp.dm1.inf_fn = 'influence_BMC_2kDM_400micron_res10.fits';
            mp.dm1.dm_spacing = 400e-6; %--User defined actuator pitch [meters]
            mp.dm1.inf_sign = '+';
            
            
            ppact = 5;
            dx = mp.dm1.dm_spacing/ppact;
            Narray = ceil(ppact*Nact*1.5/2)*2 + 1; % Needs to be odd-valued for these tests
            
            %--Change to mp.dm1.V orientation before generating DM surface. Options: rot0, rot90, rot180, rot270, flipxrot0, flipxrot90, flipxrot180, flipxrot270
            mp.dm1.orientation = 'rot0'; 
            surfRot0 = falco_gen_dm_surf(mp.dm1, dx, Narray);

            mp.dm1.orientation = 'rot90';
            surfRot90 = falco_gen_dm_surf(mp.dm1, dx, Narray);
            
            mp.dm1.orientation = 'rot180';
            surfRot180 = falco_gen_dm_surf(mp.dm1, dx, Narray);
            
            mp.dm1.orientation = 'rot270';
            surfRot270 = falco_gen_dm_surf(mp.dm1, dx, Narray);
            
            mp.dm1.orientation = 'flipxrot0'; 
            surfFlipxRot0 = falco_gen_dm_surf(mp.dm1, dx, Narray);

            mp.dm1.orientation = 'flipxrot90';
            surfFlipxRot90 = falco_gen_dm_surf(mp.dm1, dx, Narray);
            
            mp.dm1.orientation = 'flipxrot180';
            surfFlipxRot180 = falco_gen_dm_surf(mp.dm1, dx, Narray);
            
            mp.dm1.orientation = 'flipxrot270';
            surfFlipxRot270 = falco_gen_dm_surf(mp.dm1, dx, Narray);

            % Make DM poke cube
            
            mp.centering = 'pixel';
            mp.dm_ind = 1;
            mp.P2.full.dx = dx;
            mp.P2.compact.dx = dx;
            mp.sbp_centers = 575e-9;
            mp.d_P2_dm1 = 0;
            mp.d_dm1_dm2 = 0.2;

            % Read the influence function header data from the FITS file
            info = fitsinfo(mp.dm1.inf_fn);
            [~, idef] = ismember('P2PDX_M', info.PrimaryData.Keywords(:, 1)); % Get index in cell array
            dx1 = info.PrimaryData.Keywords{idef, 2}; % pixel width of the influence function IN THE FILE [meters];
            [~, idef] = ismember('C2CDX_M', info.PrimaryData.Keywords(:, 1));
            pitch1 = info.PrimaryData.Keywords{idef, 2}; % actuator spacing x (m)

            mp.dm1.inf0 = fitsread(mp.dm1.inf_fn);
            mp.dm1.dx_inf0 = mp.dm1.dm_spacing*(dx1/pitch1);

            switch lower(mp.dm1.inf_sign(1))
                case{'-','n','m'}
                    mp.dm1.inf0 = -1*mp.dm1.inf0;
                otherwise
                    %--Leave coefficient as +1
            end

            %--Create influence function datacubes for each DM
            mp.dm1.centering = mp.centering;

            mp.dm1.compact.dummy = 1;
            mdc = mp.dm1.compact;
            mp.dm1.compact = mp.dm1; % BE CAREFUL ABOUT OVERWRITING VARIABLES
            for fn = fieldnames(mdc)
                mp.dm1.compact.(fn{1}) = mdc.(fn{1});
            end
            
            % Tests
            abs_tol = 100*eps;
            
            mp.dm1.orientation = 'rot0';
            mp.dm1.compact.orientation = mp.dm1.orientation;
            mp.dm1 = falco_gen_dm_poke_cube(mp.dm1, mp, mp.P2.full.dx, 'NOCUBE');
            mp.dm1.compact = falco_gen_dm_poke_cube(mp.dm1.compact, mp, mp.P2.compact.dx);
            dmSurf = pad_crop(falco_dm_surf_from_cube(mp.dm1, mp.dm1.compact), Narray);
            maxAbsDiff = max(max(abs(dmSurf - surfRot0)));
            fprintf('maxAbsDiff = %.4g\n', maxAbsDiff);
            testCase.verifyTrue(maxAbsDiff < abs_tol)
            
            mp.dm1.orientation = 'rot90';
            mp.dm1.compact.orientation = mp.dm1.orientation;
            mp.dm1 = falco_gen_dm_poke_cube(mp.dm1, mp, mp.P2.full.dx, 'NOCUBE');
            mp.dm1.compact = falco_gen_dm_poke_cube(mp.dm1.compact, mp, mp.P2.compact.dx);
            dmSurf = pad_crop(falco_dm_surf_from_cube(mp.dm1, mp.dm1.compact), Narray);
            maxAbsDiff = max(max(abs(dmSurf - surfRot90)));
            fprintf('maxAbsDiff = %.4g\n', maxAbsDiff);
            testCase.verifyTrue(maxAbsDiff < abs_tol)
            
            mp.dm1.orientation = 'rot180';
            mp.dm1.compact.orientation = mp.dm1.orientation;
            mp.dm1 = falco_gen_dm_poke_cube(mp.dm1, mp, mp.P2.full.dx, 'NOCUBE');
            mp.dm1.compact = falco_gen_dm_poke_cube(mp.dm1.compact, mp, mp.P2.compact.dx);
            dmSurf = pad_crop(falco_dm_surf_from_cube(mp.dm1, mp.dm1.compact), Narray);
            maxAbsDiff = max(max(abs(dmSurf - surfRot180)));
            fprintf('maxAbsDiff = %.4g\n', maxAbsDiff);
            testCase.verifyTrue(maxAbsDiff < abs_tol)
            
            mp.dm1.orientation = 'rot270';
            mp.dm1.compact.orientation = mp.dm1.orientation;
            mp.dm1 = falco_gen_dm_poke_cube(mp.dm1, mp, mp.P2.full.dx, 'NOCUBE');
            mp.dm1.compact = falco_gen_dm_poke_cube(mp.dm1.compact, mp, mp.P2.compact.dx);
            dmSurf = pad_crop(falco_dm_surf_from_cube(mp.dm1, mp.dm1.compact), Narray);
            maxAbsDiff = max(max(abs(dmSurf - surfRot270)));
            fprintf('maxAbsDiff = %.4g\n', maxAbsDiff);
            testCase.verifyTrue(maxAbsDiff < abs_tol)
                        
            mp.dm1.orientation = 'flipxrot0';
            mp.dm1.compact.orientation = mp.dm1.orientation;
            mp.dm1 = falco_gen_dm_poke_cube(mp.dm1, mp, mp.P2.full.dx, 'NOCUBE');
            mp.dm1.compact = falco_gen_dm_poke_cube(mp.dm1.compact, mp, mp.P2.compact.dx);
            dmSurf = pad_crop(falco_dm_surf_from_cube(mp.dm1, mp.dm1.compact), Narray);
            maxAbsDiff = max(max(abs(dmSurf - surfFlipxRot0)));
            fprintf('maxAbsDiff = %.4g\n', maxAbsDiff);
            testCase.verifyTrue(maxAbsDiff < abs_tol)
            
            mp.dm1.orientation = 'flipxrot90';
            mp.dm1.compact.orientation = mp.dm1.orientation;
            mp.dm1 = falco_gen_dm_poke_cube(mp.dm1, mp, mp.P2.full.dx, 'NOCUBE');
            mp.dm1.compact = falco_gen_dm_poke_cube(mp.dm1.compact, mp, mp.P2.compact.dx);
            dmSurf = pad_crop(falco_dm_surf_from_cube(mp.dm1, mp.dm1.compact), Narray);
            maxAbsDiff = max(max(abs(dmSurf - surfFlipxRot90)));
            fprintf('maxAbsDiff = %.4g\n', maxAbsDiff);
            testCase.verifyTrue(maxAbsDiff < abs_tol)
            
            mp.dm1.orientation = 'flipxrot180';
            mp.dm1.compact.orientation = mp.dm1.orientation;
            mp.dm1 = falco_gen_dm_poke_cube(mp.dm1, mp, mp.P2.full.dx, 'NOCUBE');
            mp.dm1.compact = falco_gen_dm_poke_cube(mp.dm1.compact, mp, mp.P2.compact.dx);
            dmSurf = pad_crop(falco_dm_surf_from_cube(mp.dm1, mp.dm1.compact), Narray);
            maxAbsDiff = max(max(abs(dmSurf - surfFlipxRot180)));
            fprintf('maxAbsDiff = %.4g\n', maxAbsDiff);
            testCase.verifyTrue(maxAbsDiff < abs_tol)
            
            mp.dm1.orientation = 'flipxrot270';
            mp.dm1.compact.orientation = mp.dm1.orientation;
            mp.dm1 = falco_gen_dm_poke_cube(mp.dm1, mp, mp.P2.full.dx, 'NOCUBE');
            mp.dm1.compact = falco_gen_dm_poke_cube(mp.dm1.compact, mp, mp.P2.compact.dx);
            dmSurf = pad_crop(falco_dm_surf_from_cube(mp.dm1, mp.dm1.compact), Narray);
            maxAbsDiff = max(max(abs(dmSurf - surfFlipxRot270)));
            fprintf('maxAbsDiff = %.4g\n', maxAbsDiff);
            testCase.verifyTrue(maxAbsDiff < abs_tol)
                        
        end        
                
    end 

end
